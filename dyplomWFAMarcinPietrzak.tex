%% Based on a TeXnicCenter-Template by Gyorgy SZEIDL.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%------------------------------------------------------------
%
\documentclass[a4paper,12pt,reqno]{article}
%----------------------------------------------------------
\usepackage{amsfonts}
\usepackage{listings}
\usepackage{graphicx}
\usepackage{geometry}
\usepackage{xcolor}
\usepackage{amssymb,amsmath}
\usepackage{polski}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{caption}
\geometry{margin=1.1in}
\usepackage{wrapfig}
\usepackage{lipsum}  
\usepackage{listings}
\usepackage[toc,page]{appendix}
\usepackage{url}
\usepackage{float}
\usepackage{amsmath}
\usepackage{indentfirst} % pierwszy akapit zawsze z wcięciem
\usepackage{subcaption}	% kilka zdjęc w jednej lini
\usepackage{blindtext}
\usepackage[hidelinks]{hyperref}
\definecolor{codegreen}{rgb}{0.5, 0.09, 0.09}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.94,0.94,0.94}
\definecolor{gray}{rgb}{0,0.6,0}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},  
    commentstyle=\color{codegreen},
    keywordstyle=\color{blue},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
	basicstyle=\footnotesize\fontfamily{cmtt}\selectfont,
    breakatwhitespace=false,         
    breaklines=true,
    captionpos=b,
	language=C++,
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}

\lstset{style=mystyle}
\lstset{literate=%
    *{0}{{{\color{gray}0}}}1
    {1}{{{\color{gray}1}}}1
    {2}{{{\color{gray}2}}}1
    {3}{{{\color{gray}3}}}1
    {4}{{{\color{gray}4}}}1
    {5}{{{\color{gray}5}}}1
    {6}{{{\color{gray}6}}}1
    {7}{{{\color{gray}7}}}1
    {8}{{{\color{gray}8}}}1
    {9}{{{\color{gray}9}}}1
}
\lstset { %
    language=C++,
    backgroundcolor=\color{black!5}, % set backgroundcolor
    basicstyle=\footnotesize,% basic font setting
}
%------------------------------------------------------------
\begin{document}

%\begin{figure}[h]
%	\centering
%		\includegraphics[width=0.40\textwidth]{logo.pdf}
%\end{figure}


\begin{center}

\thispagestyle{empty}

%UNIWERSYTET WROCŁAWSKI\\
\Large 
Uniwersytet Wrocławski\\
Wydział Fizyki i Astronomii\\
\vspace{0.8cm}
\vspace{1.8cm}

\Large Marcin Pietrzak \\
\vspace{3.2cm}
\Large Galeria modeli komputerowych \\
\vspace{1.5cm}
Computer models gallery
\end{center}
\vspace{3.7cm}
\begin{flushright}

\large{ Praca inżynierska na kierunku \\Informatyka Stosowana i Systemy Pomiarowe \\}
\vspace{0.5cm}
\large{ Opiekun \\ dr hab. Maciej Matyka, prof. UWr}
\end{flushright}
\vspace{2.2cm}

\begin{center}
\large Wrocław, \today
\end{center}

\newpage

\tableofcontents

\newpage

\begin{flushleft}
\Large \textbf{Streszczenie}
\end{flushleft}
\vspace{1cm}


 Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.

\newpage
\begin{flushleft}
\Large \textbf{Abstract}
\end{flushleft}
\vspace{1cm}


Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur.

\newpage

\section{Wstęp}

\subsection{Wprowadzenie}

W pewnych aspektach życia człowiek zastanawia się nad paroma rzeczami, czy nie
jesteśmy sami w kosmosie, kiedy nastąpi koniec, czy VR umarł, czy nie jesteśmy
programem komputerowym. Pewnie nie poznamy odpowiedzi na te wszystkie
pytania, jeszcze przez jakiś czas, ale dzisiaj jedno jest pewne. VR na pewno jeszcze
nie umarł i ma się całkiem dobrze. W ciągu ostatnich kilku lat rynek gogli VR zaczął
na nowo się rozwijać, powstało wiele gogli, a do najpopularniejszych z nich należą:
PlayStation VR, Valve Index, HTC Vive Pro \cite{popularnosc_gogli}. Każde z tych gogli ma jednak wady, a
do najważniejszych należy to, że nie są to sprzęty typu plug and play. Trzeba się nie
tylko męczyć z splątaniną przewodów, ale także gogle jak np. Valve Index wymagają
stacji, dzięki którym gogle wiedzą gdzie znajdujesz się przestrzeni 3D. Kolejnym
problemem jest oczywiście cena samego sprzętu który w większości przekracza
ponad 3000 PLN za całość. Jedynie co się z tego zestawu różni to PlayStation VR,
same są jednak przestarzałe, a Sony zapowiedziało ich następcę którego premiera
nastąpi pod koniec 2022 roku \cite{PlayStation_VR2}. Same gogle Sony nie rozwiązały dla mnie
największego problemu, czyli obowiązek podłączenia przewodem, jednakże ten
problem na szczęście rozwiązała już inna firma, mowa oczywiście o Oculus znaną
obecnie jako Reality Labs, jedna z podfirm Facebooka obecnie znana jako Meta. Firma zaczęła
sprzedawać w 2019 gogle Oculus Quest, które były rewolucyjne z jednego ważnego
powodu, były autonomiczne, tzn. nie potrzebowały komputera do obsługi gogli,
ponieważ wystarczą do tego same gogle z kontrolerami ruchowymi. Same gogle nie
potrzebowały też stacji do określania położenia gogli, gdyż same w sobie mają diody
podczerwone które do tego służą. Oculus Quest okazał się dość rewolucyjnym
sprzętem wartym ok. 2000 pln za wersję podstawową, a rok później Oculus wypuścił
następcę za którego zapłaciliśmy jeszcze mniej czyli ok. 1500 pln w wersji
podstawowej. Nie odbyło się to bez kompromisów takich jak: Brak płynnej zmiany
rozstawu soczewek dla oczu, gorszej jakości pasek na głowę, brak magnetycznego
zabezpieczenia pojemnika na baterię. To nie znaczy oczywiścię, że gogle były
gorszę a do najważniejszych należą: Zwiększona roździelość obrazu dla jednego
oka, zmiana procesora na wydajniejszy, wydłużony czas pracy kontrolerów na jednej
baterii \cite{porownanie_gogli}. 

\begin{figure}[!ht]%
	\centering
	\begin{subfigure}{.5\textwidth}
		\centering
		\includegraphics[width=0.8\linewidth]{graphics/oculusquest.png}
		\caption{Oculus Quest 1}	
		\label{ref:subref_a}
	\end{subfigure}%
	\begin{subfigure}{.5\textwidth}
		\centering
		\includegraphics[width=0.8\linewidth]{graphics/oculusquest2.png}
		\caption{Oculus Quest 2}
		\label{ref:subref_b}
	\end{subfigure}%
	

\caption{Gogle VR od Oculusa}
\label{ref:ref}
\end{figure}

Quest 2 wśród gogli VR okazał się dużym sukcesem, w roku 2021
sprzedanych zostało 11,2 miliona sztuk urządzeń z czego 78\% to były Oculus Quest
2 \cite{Sprzedasz_gogli_VR}. Rynek aplikacji też się rozwinął w ciągu ostatnich lat. Na samego Oculusa Questa
w oficjalnym sklepie jest obecnie dostępnych ponad 300 aplikacji, na Steam jest ich
już ponad 2000. Oczywiście wśród nich nie znajdują się same gry, ponieważ gogle
mogą być wykorzystane też np. do zaprezentowania ciała człowieka, być platformą
do rysowania obrazów, lub sprzętem do relaksu czy oglądania filmów. Ja chciałem
spróbować swoich sił w stworzeniu małego projektu, który mógłby być wykorzystany
do pokazywania co ciekawego można robić w komputerze, czyli galerii modelów
komputerowych.

\begin{figure}[H]%
\centering
\includegraphics[width=0.8\columnwidth]{graphics/OpenBrush.png}
\caption{OpenBrush
\label{OpenBrush}}%
%
\qquad
\end{figure}  

\subsection{Cel i zakres pracy}

Głównym założeniem jest stworzenie aplikacji VR która przedstawi kilka wybranych
przeze mnie modeli komputerowych w przystępny sposób, łącznie z częścią galerii w
której znajdować się będzie historia danego modelu i ciekawostki z nim związane.
Gogle VR których używałem do testów to Oculus Quest pierwszej generacji,
natomiast aplikację napisałem w Unreal Engine 4, ponieważ mogę w tym silniku
pisać w języku C++, który to najbardziej z języków programowania znam, oraz w
blueprintach czyli Unrealowym wizualnym języku skryptowym, który jest przystępny
dla nowych użytkowników. Silnik posiada pełne wsparcie dla gogli VR czy to wersji
autonomicznej czy wersji PCVR. Sam aplikację pisałem z myślą o PCVR, ponieważ
nie musiałem się aż tak obawiać o ograniczenia które stawia sprzęt w wersji
androidowej np. brak wsparcia dla Unrealowych postprocesów obrazu. Projekt ten
pokazuję, że w dzisiejszych czasach dzięki dostępnym narzędziom typu UE4 i gogle
VR, człowiek jest w stanie stworzyć program w mało wymagający sposób który nie
byłby możliwy do zrealizowania jeszcze 10 lat temu.

\newpage
\section{Warstwa Użytkowa}

\subsection{Wygląd i Obsługa programu}
{\color{blue}
Program do uruchomienia wymaga gogli VR np. Oculus Quest i kontrolerów ruchowych. Można poruszać się po planszy na dwa sposoby. Pierwszy polega na użyciu lewego thumbsticka dzięki czemu można poruszać się płynnie po planszy, podczas poruszania się po planszy zmniejsza się obraz aby osoby które mają chorobę symulatorową\cite{choroba_vr} lepiej znosiły takie poruszanie się po poziomie. Drugi natomiast polega na teleportacji, po naciśnięciu przycisku B na prawy kontrolerze i wybraniu miejsca planszy gdzie chcemy się teleportować, jest to sposób poruszania się bardziej przyjazny dla osób z chorobą symulatorową.

\begin{figure}[!ht]%
	\centering
	\begin{subfigure}{.5\textwidth}
		\centering
		\includegraphics[width=0.8\linewidth]{graphics/tunnelvision.png}
		\caption{Tunnel Vision}	
		\label{ref:subref_a}
	\end{subfigure}%
	\begin{subfigure}{.5\textwidth}
		\centering
		\includegraphics[width=0.8\linewidth]{graphics/teleportmove.png}
		\caption{Teleport Move}
		\label{ref:subref_b}
	\end{subfigure}%

\caption{Różny rodzaj poruszania się w programie}
\label{ref:ref}
\end{figure}
}
\subsection{Cześć Galerii Programu}
{\color{blue}
W tej części można poczytać i dowiedzieć się trochę o danym modelu. Swoim wyglądem przypomina to galerię obrazów, gdzie osoba podchodzi do danej ciekawostki i może ją przeczytać.
}
\subsection{Część pokazowa modeli programu programu}
{\color{blue}
Ta część galerii ma pokazać użytkownikowi programu w jaki sposób wygląda dany model w działaniu. Modele obsługuję się za pomocą kontrolerów ruchowych. W zależności od modelu interakcja wygląda trochę inaczej, szczegółowo każda zostanie omówiona w sekcji dotyczącej danego modelu. 
}
\section{Warstwa Programistyczna}

\subsection{Unreal Engine 4}
{\color{red}
Program był pisany w silniku Unreal Engine 4, z powodu że korzystam z tego silnika na codzień w swojej pracy. Sam silnik wspiera też bez większym problemów gogle VR, dzięki pluginowi stworzonemu przez twórców silnika. UE4 jest silnikiem wszechstronnym, czyli nie musi byc wykorzystywany tylko do tworzenia gier. Sam silnik jest dość popularny wśród ludzi co oznacza, że w  i nie tylko można znaleźć ogrom materiałów do pomocy przy projekcie. UE4 posiada wbudowany język skryptowy zwany BluePrint, opiera się głównie bloczkach które łączą się miedzy sobą. Głównym celem BP jest chęć zdobycia widowni wśród ludzi którzy na codzień nie programują i wolą patrzeć na coś milszego dla oka. Nody są podobne do tych wykorzystywanych w blenderze. Projekt w UE4 nie musi się opierać tylko na nodach, można też większość rzeczy pisać w C++.
\begin{figure}[H]%
\centering
\includegraphics[width=0.8\columnwidth]{graphics/BPExample.png}
\caption{Przykładowy BluePrint w UE4
\label{BPExample}}%
%
\qquad
\end{figure}  

 Sam w silnik pozwala też na tworzenie poziomów w prosty i intuicyjny sposób, poprzez przeciąganie interesującego nas obiektu bezpośrednio na ekran a następnie, na jego obracanie czy nachylenie. W edytorze możemy też uruchomić interesujący na poziom i zobaczyć czy wszystko działa tak jak należy. Możemy też edytować materiał dla meshy na poziomię w podobny sposób jak tworzymy klasy aktorów, czyli poprzez nody. 
}
\subsection{Język C++}
{\color{red}
 UE4 pozwala też pisać klasy i funkcję w języku C++, a nie tylko w BP. Pisanie rzeczy C++ w UE4 nie różni się wiele od pisania w czystym C++, zaleca się oczywiście pisania rzeczy odwołujących się do biblioteki unrelea, co nie znaczy, że nie można niektóre pisać czysto w C++. Można oczywiście daną zmienną w klasie trzymać tylko w kodzie źródłowym, jeśli chcemy się odwołać do edytora UE4 i tam też coś robić musimy użyć specyfikator UPROPERTY przed zmienną i UFUNCTION przed funckja. Specyfikatory mają też dostępne opcję dzięki którym możemy np. edytować daną zmienna w edytorze lub podczas działania aplikacji. Najważniejszymi funckjami które dziedziczymi po klasach z biblioteki UE4 to Begin Play, Tick i EndPlay. BeginPlay uruchamia się kiedy dany aktor zostaję wywołany w czasię gry podsczas spawnu. Tick jest wywowyłany w każdym ticku życia aktora na poziomię. EndPlay jest wywoływany kiedy aktor kończy swój żywot. Danego aktora możemy zrobić czysto w C++ i tak samo go spawnować na levelu, ale lepiej jest stworzyć klasę dziedziczącą po nim w edytorze, staję się wtedy ona klasą BP którą możemy rozbudować o nowę funckje. Jeśli w klasię C++ stworzymy odwołonie do actor componenta, specjalna fuckcje (rozpisać co to), w klasię bp będzie widoczna jako odziedzicona po klasię C++.

\begin{figure}[H]%
\centering
\includegraphics[width=0.8\columnwidth]{graphics/CppInherited.png}
\caption{W nawiasie informacja, że odziedziczone z po klasie bazowej
\label{CppInherited}}%
%
\qquad
\end{figure}   
 
  C++ pod względem działania funkcji jest szybszy od funkcji BP, więc z doświadczenia zalecam pisania głównie w nim i dopiero w mniejszym stopniu tworzyć jakieś małe funkcje pomocnicze w BP.
  }

\subsection{Oculus Quest}

{\color{red}
 Gogle VR z których korzystam to Oculus Quest 1. Aby komunikować się z nimy korzystam z obrogramowania storzonym przez firmę Oculus, dzięki niemu mogę obsługiwać gogle na komputerzę przez sieć WiFi, a nie przez podłączenie gogli po kablu do komputera. Gogle te nie potrzebują do pracy komputera, poniewasz są w pełni autonomiczne, cała technologia skrywa się w samych goglach, dzięki czemu nie są potrzebne stacje bazowe. Aby tworzyć programy na goglach nie trzeba się specjalnie męczyć, trzeba oczywiście stowrzyć sterowania i komunikajcę ze światem wirtualnym przystosowanym specjalnie pod sterowanie ruchowe, oraz dostosawnie grafiki, aby ilośc FPS nie spadała poniżej 72 i utrzymywała je stale na tej wartości, dzięki temu nie ma większych problemów z chorobą symulatorową dla większości osób
}

\section{Jakie modele się znajdują}

\subsection{Wahadło Podwójne}

Pierwszym modelem, który zamieściłem w swoim projekcie jest model wahadła podwójnego. Wahadło podwójne składa się z dwóch wahadeł prostych, tzn. pierwsze wahadło o masie $m_0$ zostało przymocowane za pomocą pręta o długości $l_0$ do stałego punktu obrotu, gdzie $\theta_0$ jest przesunięciem kątowym wahadła od położenia równowagi. Drugie wahadło o masie $m_1$ zostało przymocowane za pomocą pręta o długości $l_1$ do pierwszego wahadła z własnym kątem swobody $\theta_1$. Z powodu występowania dwóch stopni swobody $\theta_0$ i $\theta_1$, a przez to ma bardziej złożony ruch, wahadło jest podatne na chaotyczny ruch i jest bardzo wrażliwy na warunki początkowe\cite{double_pendulum_book}.

\begin{figure}[H]%
\centering
\includegraphics[width=0.5\columnwidth]{graphics/pendulum/DoublePendulum.png}
\caption{Wahadło podwójne
\label{BPExample}}%
%
\qquad
\end{figure}  

\subsubsection{Wahadło podwójne - kod}


Kod C++ przeznaczony do tworzenia i zarządzania wahadłami składa się z trzech klas: Pendulum, PendulumSpawn, PendulumControl

W klasie Pendulum, aby obliczyć wartość $\theta_0$ i $\theta_1$ potrzebne są najpierw prędkości kątowe  $\dot{\theta_0}$ i $\dot{\theta_1}$ oraz ich przyśpieszenie kątowe $\ddot{\theta_0}$ i $\ddot{\theta_1}$. Aby obliczyć zmianie kąta w czasie trzeba rozwiązać układ równań różniczkowych. Najpierw robimy do dla kątów  $\theta_0$ i $\theta_1$, gdzie pochodna kąta od czasu jest równa $\dot{\theta_0}$ i $\dot{\theta_1}$. Teraz robimy równanie na pochodną prędkości od czasu dla $\dot{\theta_0}$ i $\dot{\theta_1}$ co daje nam przyśpieszenie kątowe $\ddot{\theta_0}$ i $\ddot{\theta_1}$.

\begin{equation}
\begin{split} 
\frac{\partial\theta_0}{\partial t}=\dot{\theta_0}
\\
\frac{\partial\theta_1}{\partial t}=\dot{\theta_1}
\\
\frac{\partial\dot{\theta_0}}{\partial t}=\ddot{\theta_0}
\\
\frac{\partial\dot{\theta_1}}{\partial t}=\ddot{\theta_1}
\end{split}
\label{thetas}
\end{equation}

Równania [\ref{thetas}] dla łatwiejszego wykorzystania możemy zapisać algebraicznie poprzez zapisanie równań różnicowych, tzn. dokonujemy przekształcenia gdzie pochodną po czasie zastępujemy prostym operatorem liniowym:

\begin{equation}
\begin{split} 
\theta_0=\theta_0+\dot{\theta_0}*dt;
\\
\theta_1=\theta_1+\dot{\theta_1}*dt;
\\
\dot{\theta_0}=\dot{\theta_0}+\ddot{\theta_0}*dt;
\\
\dot{\theta_1}=\dot{\theta_1}+\ddot{\theta_1}*dt;
\\
gdzie:
\\
dt-krok\ czasowy
\end{split}
\label{pendumalgeb}
\end{equation}

Do szczęścia brakuje nam już tylko $\ddot{\theta_0}$ i $\ddot{\theta_1}$, które można wyprowadzić ze wzoru \cite{double_pendulum}: 

\begin{equation}
\begin{split} 
\ddot{\theta_0}=\frac{g(\sin\theta_1\cos(\theta_0-\theta_1)-\mu\sin\theta_0)
-(l_1\dot{\theta_1^2}+l_0\dot{\theta_0^2}\cos(\theta_0-\theta_1))\sin(\theta_0-\theta_1)}{l_0(\mu-\cos^2(\theta_0-\theta_1))}
\\
\ddot{\theta_1}=\frac{g\mu(\sin\theta_0\cos(\theta_0-\theta_1)-\sin\theta_1)
-(\mu l_0\dot{\theta_0^2}+l_1\dot{\theta_1^2}\cos(\theta_0-\theta_1))\sin(\theta_0-\theta_1)}
{l_1(\mu-\cos^2(\theta_0-\theta_1))}
\\
gdzie:
\\
\mu=1+(m_0+m_1)
\end{split}
\label{computeAngularAcceleration}
\end{equation}

Tak wyżej utworzone równania możemy w końcu wykorzystać w kodzie do obliczenia wartości $\theta_0$ i $\theta_1$ w danym kroku czasowym.

\lstinputlisting[caption=Obliczanie wartości $\theta_0$ i $\theta_1$, label={lst:listing-cpp}, language=C++]{code/doublependulum/ComputeAnglesEuler.cpp}
\label{ComputeTheta}

%spytać się o ref do listingu

Tak wyliczone wartości $\theta_0$ i $\theta_1$ są wykorzystane do obliczenia położeń wahadeł w kolejnej funkcji. Pręta wahadeł są stworzone ze "Spline Mesh Compoment", jest to zdeformowany Static Mesh w którym podajemy mu obecnie wyliczone współrzędne wahadła, dzięki temu uzyskujemy odpowiednio wyglądające wahadło.

\lstinputlisting[caption=Aktualizacja pozycji wahadła, label={lst:listing-cpp}, language=C++]{code/doublependulum/ComputePosition.cpp}


Klasa PendulumSpawn jest natomiast odpowiedzialna za dodawanie, usuwanie wahadeł. Klasa jest też odpowiedzialna za uruchomianie i resetowanie wszystkich wahadeł które zostały przez dany PendulumSpawn stworzone.

Ostatnią klasą jest klasa PendulumControl, w której są zawarte metody i zmienne potrzebne do stworzenia interfejsu użytkownika, odpowiedzialnego za kontakt między użytkownikiem programu, a PendulumSpawn.

\subsubsection{Wahadło podwójne - UE4}
{\color{red}
Na podstawie klas C++ z poprzedniego podrozdziału stworzyłem klasy blueprintowe, które to umieszczam na poziomie w edytorze lub są wykorzystane do stworzenia interfejsu użytkownika.


W klasie BP\_Pendulum w blueprincie do najważniejszej rzeczy którą można zrobić, jest możliwość zmiany siatki 3D i materiału z którego jest stworzone wahadło:

\begin{figure}[H]%
\centering
\includegraphics[width=0.7\columnwidth]{graphics/pendulum/PendulumBP.png}
\caption{Ustawiony mesh i tekstura dla wahadła 
\label{BPExample}}%
%
\qquad
\end{figure}  

W klasie BP\_PendulumSpawn ustawiamy tylko jakie ma tworzyć wahadła oraz jaki widget ma być umieszczony do obsługi wahadeł. Po ustawieniu wszystkich potrzebnych rzeczy klasę można umieścić na poziomie:

\begin{figure}[H]%
\centering
\includegraphics[width=0.7\columnwidth]{graphics/pendulum/PendulumSpawnerBP.png}
\caption{Ustawione wahadło do stworzenia i widget 
\label{BPExample}}%
%
\qquad
\end{figure}  

 
Klasa WBP\_PendulumControl jest klasą typu widget, czyli klasą interfejsu użytkownika. W klasie tej trzeba stworzyć odpowiednie jej elementy na podstawie bazowej klasy C++, aby móc obsługiwać wahadła stworzone przez BP\_PendulumSpawn
}

\begin{figure}[H]%
\centering
\includegraphics[width=0.7\columnwidth]{graphics/pendulum/PendulumControlBP.png}
\caption{Wygląd widgetu w programie
\label{BPExample}}%
%
\qquad
\end{figure}  

\subsubsection{Wahadło podwójne – Wygląd symulacji w projekcie}
W projekcie po najechaniu wskaźnikiem z kontrolera ruchowego na panel użytkownika, możemy dodać, usunąć, uruchomić lub zresetować wahadła stworzone przez spawner. Jak pokazano na rysunku \ref{Pendulum_in_project:subref_a}, na początku symulacji wahadła są stosunkowo blisko siebie. Lecz w trakcie jej działania w pewnym momencie wahadła zaczną się zachowywać w sposób chaotyczny, tak jak to widać na rysunku \ref{Pendulum_in_project:subref_b}.


\begin{figure}[H]%
	\centering
	\begin{subfigure}{.5\textwidth}
		\centering
		\includegraphics[width=0.8\linewidth]{graphics/pendulum/PendulumInUE_1.png}
		\caption{Wahadła na początku symulacji}	
		\label{Pendulum_in_project:subref_a}
	\end{subfigure}%
	\begin{subfigure}{.5\textwidth}
		\centering
		\includegraphics[width=0.8\linewidth]{graphics/pendulum/PendulumInUE_2.png}
		\caption{Wahadła na końcu symulacji}
		\label{Pendulum_in_project:subref_b}
	\end{subfigure}%
	

\caption{Działanie programu}
\label{Pendulum_in_project}
\end{figure}

\newpage
\subsection{Gra w życie}

Gra w życie, znana też po prostu jako "Życie" nie jest tylko starą grą planszową, pod tą samą nazwą kryję się też automat komórkowy stworzony przez Johna Conwaya. Zacznijmy od tego, że automatem komórkowym jest sieć komórek, symulowanych w pamięci komputera, w którym w danej chwili każda z komórek przyjmuje określony stan, według wcześniej ustanowionych reguł\cite{game_of_life_zero_cellular_automata}. 

Krótka lekcja historii, Conway zainteresował się problemem przedstawionym w latach 40 XX wieku przez matematyka Johna von Neumanna, który to próbował znaleźć hipotetyczną maszynę, która mogłaby budować kopie samej siebie. Neumannowi udało się, gdy znalazł matematyczny model takiej maszyny z bardzo skomplikowanymi regułami na prostokątnej siatce. Gra w życie powstała jako udana próba Conwaya uproszczenia idei von Neumanna\cite{game_of_life_story}. Gra w życie Conwaya pierwotnie ukazała się w październiku 1970 roku w magazynie "Scientific American" w kolumnie "Mathematical Games" Martina Gardnera, pod tytułem: "The fantastic combinations of John Conway's new solitaire game "life""\cite{game_of_life_methematical_games}, gdzie z miejsca zdobyła dużą popularność.


 Sama Gra w życie nie jest do końca grą. Conway nazywał ją "gra bez graczy", czyli gra w której przebieg jest niezależny od gracza, a jego rola sprowadza się w tym wypadku tylko do utworzenia stanu początkowego, czyli pierwszej generacji komórek\cite{game_of_life_zero_player}. 


 Gra w pierwotnym założeniu rozgrywa się na 2 wymiarowej siatce składającej się z komórek. Każda komórka w danej turze (generacji) może być albo żywa, albo martwa. To czy pojedyncza komórka w kolejnej turze będzie żyć lub nie, zależy od stanu jej 8 sąsiadów i ustanowionych początkowych reguł.

\begin{figure}[H]%
\centering
\includegraphics[width=0.2\columnwidth]{graphics//gameoflife/GOL_Cell.png}
\caption{Pojedyncza komórka i 8 sąsiadów 
\label{BPExample}}%
%
\qquad
\end{figure} 

Gra w życie Conwaya w pierwotnych założeniach składa się z 4 zasad\cite{game_of_life_story}:

\begin{itemize}
\item Każda żywa komórka z mniej niż dwoma żywymi sąsiadami umiera
\item Każda żywa komórka mająca więcej niż trzech żywych sąsiadów umiera
\item Każda żywa komórka z dwoma lub trzema żywymi sąsiadami żyje, niezmieniona, do następnego pokolenia.
\item Każda martwa komórka z dokładnie trzema żywymi sąsiadami ożywa.
\end{itemize}


\subsubsection{Gra w życie - kod}

W C++ kod gry w życie składa się z trzech klas: CellActor, GridActor, GameOfLifeControl

CellActor jest klasą w której znajdują się informację o jednej komórce znajdującej w siatce. W klasie znajdują się informację o położeniu na dwuwymiarowej siatce (X i Y), również informację o stanie życia w obecnej generacji oraz o stanu życia w kolejnej generacji. Klasa posiada metodę Clicked, dzięki której jak użytkownik wejdzie w interakcje z komórką zmienia jej status początkowy z martwą na żywą i vice versa. 

\lstinputlisting[caption=Aktualizacja stanu danej komórki przez użytkownika, label={lst:listing-cpp}, language=C++]{code/gameoflife/CellActorClicked.cpp}

Metoda Update, która jest wykorzystywana przez GridActora, podobnie jak metoda Clicked zmienia stan życia komórki, lecz w tym wypadku wykorzystuję zmienną AliveNext.

\lstinputlisting[caption=Aktualizacja stanu danej komórki, label={lst:listing-cpp}, language=C++]{code/gameoflife/CellActorUpdate.cpp}


Klasa GridActor jest odpowiedzialna za tworzenie dwuwymiarowej siatki składającej się z CellActorów i o podanej wysokości oraz długości. W klasie odbywają się wszystkie obliczenia związane z działaniem gry w życie od obliczania obecnie żyjących sąsiadów danej komórki w metodzie CountAliveNeighbors(const int i, const int j)

\lstinputlisting[caption=Zliczanie żyjących sąsiadów danej komórki, label={lst:listing-cpp}, language=C++]{code/gameoflife/GridActorCount.cpp}

Następnie na podstawie obecnie żyjących sąsiadów i reguł jakie zostały ustawione w metodzie UpdateAliveNext(const int Index, const int NumAliveNeighbors) ustawiamy czy dana komórka w następnej klatce będzie żywa lub martwa.

\lstinputlisting[caption=Aktualizacja stanu komórki w następnej klatce, label={lst:listing-cpp}, language=C++]{code/gameoflife/GridActorAlive.cpp}

Ostatnią klasą jest GameOfLifeControll która jest odpowiedzialna
za stworzenia interfejsu użytkownika, dzięki któremu użytkownik może włączyć grę w życie, zmieniać szybkość działania gry oraz resetować ją do stanu początkowego.
\subsubsection{Gra w życie - UE4}
{\color{red}
Na podstawie powyższych klas zostały stworzone klasy BluePrintowe które można potem umieścić w na poziomie w programie. W BP\_CellActor ustawiamy jak dana komórka ma wyglądać w świecie gry i jak się zachować kiedy najedziemy na nią kontrolerem ruchowym:

\begin{figure}[H]%
	\centering
	\begin{subfigure}{.45\textwidth}
		\centering
		\includegraphics[width=0.8\linewidth]{graphics/gameoflife/CellActorInUE_1.png}
		\caption{Ustawiony mesh w programie dla komórki}	
		\label{ref:subref_a}
	\end{subfigure}%
	\begin{subfigure}{.45\textwidth}
		\centering
		\includegraphics[width=0.8\linewidth]{graphics/gameoflife/CellActorInUE_2.png}
		\caption{Ustawiony wygląd w programie podczas akcji}
		\label{ref:subref_b}
	\end{subfigure}%
	

\caption{Ustawienia dla CellActora w UE4}
\label{ref:ref}
\end{figure}

BP\_GridActor2D jest klasą BluePrint która znajdzie się na poziomie gry. W klasie ustawiamy na jaką szerokość i wysokość ma zostać stworzona siatka składająca się z BP\_CellActor oraz dodajemy widget, dzięki któremu możemy sterować symulacją:

\begin{figure}[H]%
\centering
\includegraphics[width=0.7\columnwidth]{graphics/gameoflife/GridActor2DInUE_1.png}
\caption{Ustawienia BP\_GridActor2D 
\label{BPExample}}%
%
\qquad
\end{figure}  

Na podobnej zasadzie działa BP\_GridActor3D w którym dochodzi jeszcze głębokość na którą możemy ustawić siatkę.\\

Klasa WBP\_GameOfLifeControll jest odpowiedzialna kontakt miedzy użytkownikiem a programem, klasa ta jest widgetem dzięki któremu poprzez najechanie kontrolerem ruchowym na odpowiednie opcje możemy włączyć symulację, przyśpieszyć lub ją spowolnić oraz ją zresetować do stanu początkowego:

\begin{figure}[H]%
\centering
\includegraphics[width=0.7\columnwidth]{graphics/gameoflife/GameOfLifeControllInUE_1.png}
\caption{Wygląd widgetu w programie
\label{BPExample}}%
%
\qquad
\end{figure}  
}
\subsubsection{Gra w życie - Wygląd symulacji w projekcie}
W programie za pomocą kontrolerów możemy ustawić stan początkowy każdej komórki w poprzez najechanie na nią wskaźnikiem wystającym z kontrolerów.

\begin{figure}[H]%
	\centering
	\begin{subfigure}{.5\textwidth}
		\centering
		\includegraphics[width=0.8\linewidth]{graphics/gameoflife/GOLInUE_1.png}
		\caption{Ożywianie komórek z pomocą kontrolera}	
		\label{ref:subref_a}
	\end{subfigure}%
	\begin{subfigure}{.5\textwidth}
		\centering
		\includegraphics[width=0.8\linewidth]{graphics/gameoflife/GOLInUE_2.png}
		\caption{Uśmiercanie komórek z pomocą kontrolera}
		\label{ref:subref_b}
	\end{subfigure}%
\label{ref:ref}
\end{figure}

Po lewej stronie od tablicy z komórkami znajduję się widżet, na którym możemy włączyć grę, przyśpieszyć jej działanie lub spowolnić, albo zresetować komórki do stanu początkowego. 

\begin{figure}[H]%
	\centering
	\begin{subfigure}{.5\textwidth}
		\centering
		\includegraphics[width=0.8\linewidth]{graphics/gameoflife/GOLInUE_1.png}
		\caption{Wygląd tablicy z komórkami i widżetu}	
		\label{ref:subref_a}
	\end{subfigure}%
	\begin{subfigure}{.5\textwidth}
		\centering
		\includegraphics[width=0.8\linewidth]{graphics/gameoflife/GOLInUE_2.png}
		\caption{Wygląd tablicy w trakcie uruchomienia gry}
		\label{ref:subref_b}
	\end{subfigure}%
\label{ref:ref}
\end{figure}

\newpage
\subsection{Efekt Motyla}

"Dowolny układ fizyczny, który zachowuje się nieokresowo, jest nieprzewidywalny." Są to słowa Edwarda Lorenza, meteorologa który jako pierwszy odkrył, że nie można zrobić dobrej prognozy pogody na dłużej niż kilka dni do przodu. W 1960 roku pracował on nad programem komputerowym który miał prognozować pogodę, na podstawie zbioru równań określających zależności między prędkością wiatru, temperaturą, ciśnieniem i wilgotnością\cite{burze_motyle}. Gdy Lorenz testował swój program po wprowadzeniu danych i po wydrukowaniu wyniku w formie wykresu. Rozkład maksimów i minimów na wykresie wyglądał tak, jak się tego spodziewał Edward. Postanowił jednak ponownie zbadać wyniki, dlatego uruchomił program ponownie, wprowadzając jak myślał takie same wyniki\cite{burze_motyle}. Okazało się jednak, że wyniki wyszły na odwrót. Po sprawdzeniu danych zauważył, że podał je w postaci przybliżonej z mniejszą liczbą cyfr po przecinku. Było to dla niego tak ciekawe, że spróbował to samo z innymi zbiorami danych i zaobserwował identyczne zjawisko. Lorenz w ten sposób odkrył "efekt motyla", gdzie dla pewnych układów deterministycznych nawet minimalne zmiany wartości danych początkowych zostają bardzo szybko wzmocnione i powodują ogromne zmiany w ewolucji układu\cite{burze_motyle}.

\begin{figure}[H]%
\centering
\includegraphics[width=0.7\columnwidth]{graphics/butterfly/josep_castells_burza.jpg}
\caption{Burza 
\label{BPExample}}%
%
\qquad
\end{figure} 

Obecnie układ Lorenza jest bardziej znany jako układ 3 nieliniowych
równań różniczkowych\cite{lorenz_dziwne_atraktory}:

\begin{equation}
\begin{split}
\dot{x}=\sigma(y-x)\\
\dot{y}=x(\rho-z)-y\\
\dot{z}=xy-\beta z\\
\end{split}
\end{equation}

gdzie:\\
sigma - stała Prandtla,\\
rho - stała Rayleigha,\\
beta - obszar obejmujący równania\\
sigma,rho,beta>0,\\
Jednakże zwykle podaje się\cite{lorenz_dziwne_atraktory}:\\
\begin{equation}
\begin{split}
sigma = 10\\
rho = \frac{8}{3}\\
beta - zmienna
\end{split}
\label{ButterflyVariables}
\end{equation}

\subsubsection{Efekt Motyla - kod}

Kod C++ składa się z dwóch klas ButterflyActor i ButterflySpawner.
W ButterflyActor najważnejszą metodą jest Tick(float DeltaTime) w której poprzez rozwązanie wczęśniej pokazanych równań różniczkowych po przecałkowaniu. Następnie odpowiednio ustawiamy te równania dla pozycji X, Y i Z danego aktora\cite{motyle_cpp}

\lstinputlisting[caption=Metoda Tick(), label={lst:listing-cpp}, language=C++]{code/butterfly/ButterflyActorTick.cpp}

Jedyną rolą ButterflySpawner jest utworzenie tyle ButterflyActor ile zostanie mu zadane na początku, z drobną zmianą odległości dla każdego kolejnego aktora.


\lstinputlisting[caption=Tworzenie nowych atraktorów, label={lst:listing-cpp}, language=C++]{code/butterfly/ButterflySpawner.cpp}

\subsubsection{Efekt Motyla - UE4}

Na podstawie powyższych klas zostały stworzone klasy BluePrintowe które można potem umieścić w na poziomie w programie. W BP\_ButterflyActor dla którego stworzyłem efekt cząsteczkowy który zostawia ścieżką jaką poruszał się dany aktor.

\begin{figure}[H]%
\centering
\includegraphics[width=0.7\columnwidth]{graphics/butterfly/ButterflyParticleSystem.png}
\caption{Wygląd menu do tworzenia efektów cząsteczkowych w UE4 
\label{BPExample}}%
%
\qquad
\end{figure} 


W BP\_ButterflySpawner ustawiamy jakiego aktora chcemy ustawić na scenie, oraz ile motyli chcemy stworzyć.

\begin{figure}[H]%
\centering
\includegraphics[width=0.7\columnwidth]{graphics/butterfly/ButterflySpawner.png}
\caption{Wygląd menu do tworzenia efektów cząsteczkowych w UE4 
\label{BPExample}}%
%
\qquad
\end{figure} 


\newpage
\subsubsection{Efekt Motyla - Wygląd symulacji w projekcie}
{\color{blue}
W programie użytkownik może obserwować efekt motyla z podstawowymi parametrami dla atraktorów[\ref{ButterflyVariables}], łącznie ze ścieżka, po jakiej się poruszają się atraktory:

\begin{figure}[H]%
\centering
\includegraphics[width=0.7\columnwidth]{graphics/butterfly/ButterflyInUE_1.png}
\caption{Wygląd motyli w programie
\label{ButterflyEffectUE4}}%
%
\qquad
\end{figure}  
}
\newpage
\subsection{Modele Agentowe}

Model agentowy jest typem modelu gdzie analizujemy wpływ agenta na dane środowisko i vice versa. Agentem może być np. komórka, człowiek, zwierzę itd. W modelu agentowym ustawiamy zachowanie poszczególnego lub grup agentów i obserwujemy jak wpływają na resztę w danym środowisku testowym. Główną ideą jest sprawdzenie w jaki sposób czynniki w mikro skali wpływają na czynniki w środowisku makro. Dzięki temu możemy wykorzystać tak zdobytą wiedzę do różnych celów np. Sprawdzenie roznoszenia się epidemii, badać zachowania konsumenckie u ludzi czy tworzyć proste środowiska  by zobaczyć jak populacja danych agentów zmieniała się w czasie.\cite{agent_examples} 

W Unrealu Engine 4 stworzyłem prosty model środowiska, gdzie mamy 3 rodzaje agentów: Rośliny, Króliki i Lisy. Celem królików jest rozmnożenie się poprzez znalezienie najbliższego królika do tego zdolnego. Jeśli trakcie trwania symulacji zdrowie królika spadnie poniżej danego poziomu, ponieważ w trakcie trwania symulacji każdy agent nieustannie traci zdrowie lub w trakcie rozmnażania, jego celem wtedy jest znalezienie najbliższej rośliny i skonsumowanie jej. Po zjedzeniu rośliny może ponownie szukać partnera do rozmnażania.  Celem lisa podobnie jak królika jest znalezienie partnera do reprodukcji. Podobnie jak królik w wyniki rozmnażania lub czasu traci zdrowie, wtedy jego celem jest znalezienie najbliższego królika i zjedzenie go. Aby każdy miał jakieś szansę na przeżycie wartości prędkości danej grupy agentów różnią się. W obecnym modelu króliki są szybsze od lisów, ale mają też mniej od nich mniej zdrowia. Króliki mają też wyższy licznik reprodukcji. Model też jest bardzo prosty dlatego np. króliki nie uciekają od lisów.
\subsubsection{Modele Agentowe - kod}

Kod C++ składa się z następujących klas: AgentBase, PlantAgent, RabbitAgent, WolfAgent, AgentSpawner, AgentSpawnBox, AgentTable i AgentControl. 
AgentBase jest klasą bazową dla kolejnych trzech rodzajów agentów. W jego skład wchodzi informacja jaki mesh ma dany agent, prosty system kolizji wykorzystywany do interakcji z innymi agentami i użytkownikiem, stan zdrowia oraz informacja o spawnerze na mapie. Każdy agent ma odpowiednio własny zakres zachowań, takich jak: początkowy stan zdrowia czy prędkość. Każdy agent ma też funkcję które odziedziczyli po klasie bazowej, odpowiedzialne za inne zachowania. Do najważniejszych należą funkcja Move() w której dzieje się ruch danego agenta. Przykładowa w RabbitAgent, w zależności od jego stanu zdrowia albo szuka pożywienia albo partnera do kopulacji w pewnej odległości od niego by następnie się do niego zbliżać z zadaną mu prędkością. Jeśli jego zdrowie jest równe 0 dany agent się niszczy.

\lstinputlisting[caption=Metoda Move(), label={lst:listing-cpp}, language=C++]{code/agent/AgentActorMove.cpp}

Kolejną ważną metodą w każdym agencie jest OnOverlapBegin(), jest to metoda która poprzez napisanie jej w taki sposób ma możliwość generowanie eventów kiedy jakiś inny obiekt wejdzie w obszar jego interakcji. Dla RabbitAgent, w zależności od aktora i obecnych potrzeb ma inne zastosowania. Jeśli królik obecnie poszukuję rośliny i wejdzie z nią w obszar interakcji, roślinę usuwa, a sam zyskuję zdrowie. Jeśli obecnie poszukuję partnera i wejdzie w jego obszar interakcji, dany agent jak i jego partner tracą zdrowie do danego poziomu, a następnie tworzą nowych agentów.
	
\lstinputlisting[caption=Interacja agenta z innymi agentami, label={lst:listing-cpp}, language=C++]{code/agent/AgentActorOverlap.cpp}

Kolejną klasą jest AgentSpawner którego głównym zadaniem jest kontrola populacji, aby nie przekroczyła zadanej ilości oraz by w razie potrzeby dodał nowych agentów danego rodzaju, jeśli ci się skończą na planszy. Na przykład kiedy na planszy nie ma już AgentRabbit, spawner generuję nowe króliki w danej ilości i umieszcza je w losowych miejscach na planszy

\lstinputlisting[caption=Dodawanie nowych agentów metodzie Tick(float DeltaTime), label={lst:listing-cpp}, language=C++]{code/agent/SpawnerActorReproduction.cpp}
Drugim zadaniem jest też włączanie i wyłączanie wszystkich agentów na planszy.

Kolejną klasą jest AgentSpawnBox. Podobnie jak AgentSpawner tworzy nowych agentów, ale z tą róźnicą, że do pomocy potrzebuję gracza. W klasie tej nowy agent danego rodzaju jest tworzony, kiedy gracz wejdzie w interakcję z tym obiektem za pomocą kontrolera ruchowego. Dzięki temu, gracz może "wyciągnąć" nowego agenta i postawić go na planszy w takim miejscu jakim chce. 

Kolejną klasą jest AgentTable. Ustawia on jedynie tych agentów których gracz postawi na planszy.

Ostatnia klasą jest AgentControl, który odpowiada za tworzenie UI i komunikację pomiędzy graczem, a klasą odpowiedzialną za działanie agentów, czyli AgentSpawner. 

\subsubsection{Modele Agentowe - UE4}

Na podstawie kodów C++ stworzyłem w UE4 odpowiednie klasy BluePrintowe, które są dziećmi klas z kodu źródłowego. Klasy BP\_RabbitAgent, BP\_PlantAgent i BP\_WolfAgent
Ustawia się w taki sam sposób, poprzez wybranie odpowiedniego mesha jakiego chcemy dla danego agenta i wybrać jakiego actora ma stworzyć w trakcie etapu reprodukcji, z wyłączeniem PlantAgent, który powstaje tylko w AgentSpawner. Tutaj też wybieramy, jaki kolor ma mieć actor, kiedy będziemy w nim wchodzić w interakcje na etapie ręcznego tworzenia planszy.

\begin{figure}[H]%
\centering
\includegraphics[width=0.4\columnwidth]{graphics//agent/BP_AgentActor.png}
\caption{Ustawienia Agentów w UE4 
\label{BPExample}}%
%
\qquad
\end{figure} 


Kolejną klasą jest BP\_Spawner, która zostanie umieszczona na poziomie. W niej ustawiamy jakich dokładnie agentów chcemy ustawić, których stworzyliśmy w BluePrintach oraz jak duży ma być obszar tworzenia nowych agentów przez spawner.

\begin{figure}[H]%
\centering
\includegraphics[width=0.6\columnwidth]{graphics//agent/BP_SpawnerAgent.png}
\caption{Ustawienia Spawnera w UE4 
\label{BPExample}}%
%
\qquad
\end{figure} 

Kolejną klasą jest BP\_AgentSpawnBox. Podobnie jak BP\_Spawner tworzy nowych agentów, z tą różnicą, że w nim ustawiamy tylko jeden rodzaj agenta do stworzenia. Po ustawieniu agenta za pomocą kontrolerów ruchowych, możemy go postawić na planszy.

\begin{figure}[H]%
\centering
\includegraphics[width=0.50\columnwidth]{graphics//agent/BP_AgentSpawnBox.png}
\caption{Ustawienia SpawnBox w UE4 
\label{BPExample}}%
%
\qquad
\end{figure} 

Ostatnie dwie klasy to BP\_AgentTable i BP\_AgentControl. Pierwsza w nim jest planszą w której ustwiamy jak plansza ma wyglądać oraz miejsce gdzie możemy położyć i zabrać agentów. Drugą klasa jest widgetem i tak jak w poprzednich modelach, poprzez najechanie kontrolerem na odpowiednią opcje symulacja startuję, albo się resetuje.

\begin{figure}[H]%
	\centering
	\begin{subfigure}{.5\textwidth}
		\centering
		\includegraphics[width=0.8\linewidth]{graphics//agent/BP_AgentTable.png}
		\caption{Wygląd planszy w UE4}	
		\label{ref:subref_a}
	\end{subfigure}%
	\begin{subfigure}{.5\textwidth}
		\centering
		\includegraphics[width=0.8\linewidth]{graphics//agent/BP_AgentControl.png}
		\caption{Wygląd widgetu w UE4}
		\label{ref:subref_b}
	\end{subfigure}%
\label{ref:ref}
\end{figure}

\subsubsection{Modele Agentowe - Wygląd symulacji w projekcie}
W programie za pomocą kontrolerów możemy wyciągać agentów z SpawnBoxów i kłaść ich następnie na planszy. Każdy rodzaj agenta ma swój własny SpawnBox różniący się wyglądem.

\begin{figure}[H]%
	\centering
	\begin{subfigure}{.5\textwidth}
		\centering
		\includegraphics[width=0.8\linewidth]{graphics//agent/AgentInUE_1.png}
		\caption{SpawnBoxy w programie}	
		\label{ref:subref_a}
	\end{subfigure}%
	\begin{subfigure}{.5\textwidth}
		\centering
		\includegraphics[width=0.8\linewidth]{graphics//agent/AgentInUE_1.png}
		\caption{Wyciąganie agenta z SpawnBoxu}
		\label{ref:subref_b}
	\end{subfigure}%
\label{ref:ref}
\end{figure}

Każdego agenta z SpawnBoxu możemy położyć w dowolnym miejscu na planszy. Kiedy agent zmieni kolor na żółty, oznacza to że możemy go spokojnie postawić i że nie zniknie. Agenta z planszy możemy też przełożyć w inne miejsce lub go usunąć poprzez wyciągnięcie go z planszy, a następnie poprzez puszczenie trzymanego agenta poza planszą.

\begin{figure}[H]%
	\centering
	\begin{subfigure}{.5\textwidth}
		\centering
		\includegraphics[width=0.8\linewidth]{graphics//agent/AgentInUE_1.png}
		\caption{Kładzenie agenta na planszy}	
		\label{ref:subref_a}
	\end{subfigure}%
	\begin{subfigure}{.5\textwidth}
		\centering
		\includegraphics[width=0.8\linewidth]{graphics//agent/AgentInUE_1.png}
		\caption{Plansza z agentami}
		\label{ref:subref_b}
	\end{subfigure}%
\label{ref:ref}
\end{figure}

Symulację uruchamiamy poprzez najechanie kontrolerem na przycisk start który znajduję się na widgecie przed planszą. Symulacja będzie trwać dopóki nie wyłączymy jej drugim przyciskiem. Podczas symulacji agenci będą się poruszać zgodnie z zachowaniami, jakie im zostały stworzone w kodzie.

\begin{figure}[H]%
\centering
\includegraphics[width=0.5\columnwidth]{graphics/agent/AgentInUE_1.png}
\caption{Wygląd symulacji w trakcie jej działania
\label{BPExample}}%
%
\qquad
\end{figure}  



\newpage
\subsection{Boids}

W roku 1986 w ciągu dwóch miesięcy, Craig Raynolds pracujący wtedy w firmie "Symbolics" stworzył model komputerowy skoordynowanego ruchu zwierząt takich, jak ławica ryb czy stado ptaków. Model ten był oparty na trójwymiarowej geometrii, którą zwykle używa się animacji komputerowej. Stworzenia wchodzące w skład modelu nazwał "boid", które w dialekcie Nowo Jorskim oznaczają również ptaki, a samą nazwę podobno zainspirował się z filmu "The Producers" Mela Brooksa \cite{boids_name}. Sam podstawowy model stada opiera się na 3 prostych zasadach \cite{flocking_system}:

\begin{itemize}
\item Separacja(a): Odpowiedzialne za unikanie kolizji pobliskich członków stada poprzez unikanie nagromadzenia ich w pobliżu
\item Wyrównanie(b): Odpowiedzialne aby przemieszanie było uśrednione do innych pobliskich członków stada
\item Spójność(c): Odpowiedzialne za utrzymanie bliskości członków stada, poprzez poruszanie się obiektu w kierunku średniej pozycji pobliskich członków
\end{itemize}

\begin{figure}[H]%
	\centering
	\begin{subfigure}{.3\textwidth}
		\centering
		\includegraphics[width=0.8\linewidth]{graphics/boids/Separation.png}
		\caption{Separacja}	
		\label{ref:subref_a}
	\end{subfigure}%
	\begin{subfigure}{.3\textwidth}
		\centering
		\includegraphics[width=0.8\linewidth]{graphics/boids/Alignment.png}
		\caption{Wyrównanie}
		\label{ref:subref_b}
	\end{subfigure}%
		\begin{subfigure}{.3\textwidth}
		\centering
		\includegraphics[width=0.8\linewidth]{graphics/boids/Cohesion.png}
		\caption{Spójność}
		\label{ref:subref_c}
	\end{subfigure}%
\label{ref:ref}
\end{figure}

Każdy z boidów reaguję tylko na inne boidy w jego bliskim otoczeniu od niego, a każdy boid z poza tego otoczenia jest ignorowany. W początkowych eksperymentach, model był trochę bardziej rozbudowany, dzięki czemu boidy, mogły omijać obiekty i poszukiwać celu \cite{boids_reynolds}. Na podstawie kodu \cite{code_boids} zrobiłem prostą wersję która działa z kontrolerami ruchów VR do możliwości sterowania ruchami stada, stado porusza się za obiektem.

\subsubsection{Boids - kod}

Kod C++ składa się z następujących klas: BoidTarget, BoidManager, BoidSpawner Boid,  i BoidsMenu. 

BoidTarget jest z nich najmniej rozbudowany, ponieważ jest tylko aktor z ustawionym meshem i materiałem. Jego jedynym celem jest ustawienie miejsca do którego mają zmierzać boidy, kiedy będziemy tego chcieli.

BoidManager jest klasą odpowiedzialną za zarządzaniem wszystkimi boidami na poziomie. W każdej klatce dla każdego boida odpalanie jego obliczanie rotacji oraz ją aktualizuję, tak samo robi z pozycją każdego boida.

\lstinputlisting[caption=Metoda Tick(), label={lst:listing-cpp}, language=C++]{code/boids/BoidManagerTick.cpp}

W BoidManager są też informacje o tym, czy boidy mają udać się w stronę wyznaczonego celu. Znajduję się równiesz informację z jaką siłą mają działać trzy zasady dotyczące boidsów. Siłę działania zasad oraz podążanie za celem ustawiamy potem w widgecie, który jest dzieckiem klasy BoidsMenu.

BoidSpawner jest odpowiedzialny za tworzenie nowych boidów, w takiej ilości jaką mu zadamy oraz w danej mu odległości.

W klasie Boid odbywają się wszystkie obliczenia dotyczące 3 zasad. Dla każdej zasady pomiędzy obecnym Boidem a danymi w pobliżu, obliczamy wektor separacji, spójności i wyrównania.Po obliczeniu wektorów są dzielone przez liczbę pobliskich boidów i normalizowane.

\lstinputlisting[caption=Metody obliczające odpowiednie wektory, label={lst:listing-cpp}, language=C++]{code/boids/BoidSAH.cpp}

Jeśli śledzimy cel, to dodajemy też znormalizowany wektor pomiędzy pozycją celu i boida. Na koniec każdy wektor, po wcześniejszym pomnożeniu przez ich siłę z BoidManger, dodajemy do wektora interpolacji i mnożymy przez daną prędkość obrotu oraz normalizujemy, aby stworzyć rotator, który będzie kolejną rotacją boida.

\lstinputlisting[caption=Obliczanie rotacji boida, label={lst:listing-cpp}, language=C++]{code/boids/BoidCalcRot.cpp}

\subsubsection{Boids - UE4}

Na podstawie kodów C++ stworzyłem w UE4 odpowiednie klasy BluePrintowe, które są dziećmi klas z kodu źródłowego. 

W BP\_BoidTarget ustawiamy tylko mesh i materiał, a następnie umieszczamy ją na poziomie. Podobnie z BP\_Boid w którym też ustawiamy tylko mesh i materiał, ponieważ cała logika została stworzona w C++.

\begin{figure}[H]%
	\centering
	\begin{subfigure}{.5\textwidth}
		\centering
		\includegraphics[width=0.8\linewidth]{graphics//boids/BP_BoidTarget.png}
		\caption{Ustawienia BoidTarget w UE4 }	
		\label{ref:subref_a}
	\end{subfigure}%
	\begin{subfigure}{.5\textwidth}
		\centering
		\includegraphics[width=0.8\linewidth]{graphics//boids/BP_Boid.png}
		\caption{Ustawienia Boid w UE4 }
		\label{ref:subref_b}
	\end{subfigure}%
\label{ref:ref}
\end{figure}


BP\_BoidManager i BP\_BoidSpawner też nie mają rozbudowanych opcji. W pierwszym nic nie zmieniamy, ponieważ jego ustawienia będę wykorzystywane przez w widget. W drugim notomiast ustawiamy, czy ma być aktywny, jakie boidy ma robić oraz ich ilość i wielkość obszaru w którym mają być tworzone od niego.

\begin{figure}[H]%
	\centering
	\begin{subfigure}{.5\textwidth}
		\centering
		\includegraphics[width=0.8\linewidth]{graphics//boids/BP_BoidManager.png}
		\caption{Ustawienia BoidManager w UE4 }	
		\label{ref:subref_a}
	\end{subfigure}%
	\begin{subfigure}{.5\textwidth}
		\centering
		\includegraphics[width=0.8\linewidth]{graphics//boids/BP_BoidSpawner.png}
		\caption{Ustawienia BoidSpawner w UE4 }
		\label{ref:subref_b}
	\end{subfigure}%
\label{ref:ref}
\end{figure}

WBP\_BoidHud tak jak wszystkie widgety w poprzednich symulacjach, po najechaniu kontrolerem ruchowym, możemy wybrać to czy boidy mają podążać za celem, czy się będą rozpraszać po okolicy. Możemy też wybrać z jaką siłą ma być wykonywana jedna z trzech zasad rządząca boidamy, oraz jak blisko ma się zbliżyć celu. 

\begin{figure}[H]%
\centering
\includegraphics[width=0.55\columnwidth]{graphics/boids/BP_BoidHud.png}
\caption{Boids w programie
\label{BPExample}}%
%
\qquad
\end{figure}  

\newpage
\subsubsection{Boids - Wygląd symulacji w projekcie}

W programie nad lewym kontrolerze mamy widget którym sterujemy zaochawniem boidów. Za pomocą prawego kontrolera możemy ustawić opcje np. ustawić czy boidy mają podążać za targetem oraz możemy wrócić do galerii.

%Dodaj jak wyglądają kontolery w boidsach

\begin{figure}[H]%
	\centering
	\begin{subfigure}{.5\textwidth}
		\centering
		\includegraphics[width=0.8\linewidth]{graphics//boids/BoidsInUE.png}
		\caption{Boidy zmierzają w kierunku targetu }	
		\label{ref:subref_a}
	\end{subfigure}%
	\begin{subfigure}{.5\textwidth}
		\centering
		\includegraphics[width=0.8\linewidth]{graphics//boids/BoidsInUE.png}
		\caption{Boidy się rozpraszają}
		\label{ref:subref_b}
	\end{subfigure}%
\label{ref:ref}
\end{figure}

Po kliknięciu na prawym kontrolerze spustu możemy zmienić położenie targetu do którego mogą zmierzają boidy.

\begin{figure}[H]%
\centering
\includegraphics[width=0.7\columnwidth]{graphics/boids/BoidsInUE.png}
\caption{Przesuwanie targetu w programie w programie
\label{BPExample}}%
%
\qquad
\end{figure}  

\newpage
\section{Realizacja projektu}

\newpage
\section{Wnioski}


\newpage

\bibliographystyle{unsrt}
\bibliography{bibliografia}

{\color{blue} kolor blue: rozpisać}\\
{\color{red} kolor red: edytować i może dodać}\\
{\color{green} kolor green: wymyślić co dodać}

\end{document}




